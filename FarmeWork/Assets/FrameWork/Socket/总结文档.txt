一些注意点：
	发送接受方式：
		1、开线程,线程内同步发送数据
		2、使用异步通信

		选择的是第一种,因为异步发送时,缓冲区写满就返回,此时包可能还没发完,所以多了一步验证包的完整性


	黏包分包
		通过包体长度分包
		一个大的接收数据数组,里面存放接收到的数据,读取最前面的四个字节,是长度,然后读取对应的数组长度,解析为包体


	设置
		禁用延迟,系统缓冲区的设置


	连接超时:
		自己写,C#的Socket不能设置连接超时,且默认超时是22s,太长了
		用的是协程,异步连接,然后while循环卡住,判断是否连接成功


	重连机制:
		当断开时,设定个最大重连次数
		注意：
			1、有可能一直连接断开,这样不会超最大重连次数,玩家不知道网不好,但是卡住了,设定个短时间内最大连接次数,超过了就提示玩家网不行
			2、当断开时,服务器发送的一些数据可能会丢失
				1、重连上之后,所有数据全部重新拉取
				2、服务器缓存下之前一段时间发送的包,客户端记录着收到的最后一个包的id号,重连上之后发给服务器,服务器把此id号之后的包在重新发一次


	心跳机制:
		每隔一段时间发送心跳包,超过3次没收到就断开连接
		因为系统提供的方式有时判断不出来,
			Poll+Receive返回0的方法,意外断开的时候判断不出来
			Connected 属性,是上次通信的状态,上次正常就是true,上次不正常就是false
		心跳保活
			在线程内发送
			接收时看下是否保活,保活的话就直接执行对应逻辑(同步时间等等)
				否则只发送,在主线程执行逻辑,就会导致当切换到后台时,累计了不同时间的心跳包,导致时间同步出现问题

	大端小端
		大端：低地址存放高位字节
		小端：低地址存放低位字节
		使用BitConverter.IsLittleEndian判断硬件模式,统一转换为一种模式


	缓冲区数据的清除
		断开连接时清除下黏包分包使用的缓冲区数据
		更换账号时清楚下所有未走逻辑的包体数据


代码设计：
	SocketHelper 是主体逻辑，负责连接,发送,接收数据
	DataHolder 负责分包
	DataStream 负责写入字节,读取字节
	ProtoManager 负责绑定协议号与对应的处理逻辑

	ReConnectObj 是重连对象
	HeartbeatObj 是心跳对象
	SocketHelper:
	封装了socket通信逻辑
	Connect 接口连接服务器
	SendPacket 接口发送包

		Packet：
			包的基本单位,里面包含了 包的协议类型、包体
				包体是protobuff生成的对象

		DataHolder：
			数据切割类,用来进行黏包,半包的拆分,里面包含了一个缓存池,接收到的所有数据都放入缓存池中,然后再切割

			切割逻辑:
				客户端与服务器通信的数据从前到后包含3部分：包的长度,包的协议类型,包体
				客户端收到包,先读取前4个字节,这是包的长度,表明了  包的协议类+包体 的总长度
				然后从缓存池中取出对应长度的数据
				在读取4个字节,这是包的协议类型,根据协议类型判断是哪个包,然后调用对应包的protobuff反序列化

		DataStream：
			封装的一个流读取 与 写入的逻辑，使用方便些

		ProtoManager：
			协议管理类,记载每个协议对应的收包逻辑


		使用时：
			需要将 SocketHelper的 AddRespDelegate 与 DeserializePack 放入对应的业务层逻辑即可
			AddRespDelegate 是 添加每一个协议对应的类型 的委托
			DeserializePack 是 反序列化包的逻辑

	设计优化：
		1、如果客户端同时与多个服务器连接,那么可以写个SocketMgr,一个SocketHelp代表和一个服务器的链接
			同时把线程放在ScoketMgr里面,所有连接的发送与接收都只用两个线程就可以了
		2、接收的缓冲区只实例化一个数组,然后指出数组的有效数据即可,可以不用每次都实例化
		3、写个服务器连接配置,把静态的配置数据写上

	

	问题：
		1、服务器不要发送剩余几秒的数据,而应该直接发送时间戳
			因为客户端不一定什么时候执行这个包,比如切换到后台时,此时剩余几秒的数据很容易出问题