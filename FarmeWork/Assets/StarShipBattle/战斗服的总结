战斗服的总结

底层：
	网络通信部分：
		使用了一个PESocket框架,有作为服务器的部分,有作为客户端的部分
		作为服务器：
			监听端口,等待连接,然后异步通信接收数据

		继承会话类,重写当接收包的逻辑即可

		问题：
			数据是在其他线程内获取到的,如果获取数据直接执行逻辑,那么逻辑也在其他线程内执行了,这不行
			办法：
				写个线程数据类,统一记录所有多线程的数据,添加与用到的方法内加锁,则可以在主线程内获取
	

系统设计
	Main方法内开个while无限循环,作为Update()方法,每次循环沉睡1ms
	一场战斗一个战斗管理类
	战斗管理类包含逻辑模块,时间模块,通信模块,日志模块

	逻辑模块控制整场战斗的运转

	时间模块维护战斗运转时间
		运转时间从0开始,服务器与客户端都用的运转时间来计算
		运转时间是同步的,都是用的当前时间戳减去开始时间戳

		暂停：
			当暂停时,统计暂停时间,减去暂停时间才是运转时间

	通信模块负责和客户端以及游戏服的通信,还有一些数据包的处理(心跳机制,战斗回放)

		记录了客户端的Socket连接以及和这张战斗关联的游戏服的链接
		客户端：
			包里有个发送时间数据,客户端那边会判断当前是否过了发送时间,过了再取出来执行,没过就先放入池子中
				服务器在某个运行时间点发送的数据包,客户端肯定是在这个时间点所在帧收到的
			优化：
				基础数据包
					可以把所有物体属性的更改做成一个包,减少包的发送
				指令集合包
					把一帧内所有的指令合成一个指令包,发给客户端

				延迟发送
					客户端比服务器延迟一定时间执行,这样可以减少网络波动造成的影响
					但是因为玩家可以操作,延迟时间大的话玩家会感觉到延迟,所以设置为100ms

			问题：
				断线重连
					没做,断了线就直接逃跑了,因为重连上之后,不好复原

		游戏服：
			包里有roleid,通过roleid判断是哪场战斗

	日志模块提供些日志的接口,根据不同情况写入不同文件,使用NLog插件
		1、目录名称设计
			一场战斗一个日志文件
			目录划分:日期/玩家id/日志文件
			日志名称:开始战斗的时间_战斗服的id

		2、日志服
			写日志是一个比较耗性能的操作,所以做个日志服,所有战斗服的日志都发给一个日志服
			日志服
				使用HttpListener接口做监听
				防止扫描
					1、日志服的端口只对内网开放
					2、发送连接里面加个标志,有这个标志才去读数据,做处理
				内网地址
					使用内网地址才会走内网流量
				权限问题
					好像得要管理者运行
			战斗服:
				开个线程,所有日志通过Http发送给日志服
				日志池子
					发送时会有个日志池子,日志发送频繁可能会导致池子越积越多
					所以写个池子最大容纳量,超过的日志直接清除了

		3、日志的限制
			有可能Update内出了个报错,导致疯狂写错误日志,导致服务器卡死
			所以做个固定时间内最大写入日志数量的限制

		4、日志的定期清除
			使用批处理,定期清除一段时间之前的日志,防止日志一直增加,磁盘占满


	性能统计
		统计点：
			CPU:每帧运行时间,最大时间
			网络:消耗带宽,发送接收数据量
			内存消耗

问题：
	船员死亡,会导致舱室的船员集合增减,到时遍历会漏掉船员
	被动技能可以不做成公共属性
		比如吸血,攻击会回血,但是如果敌方死亡爆炸,炸死了我,那么我就不能回血了
		做成公共属性,就得考虑死不死,但是做成被动技能,就可以不用考虑,因为触发流程就有死不死的判断逻辑